# -*- coding: utf-8 -*-
"""Rayleigh_Ritz_method_for_waveguides.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-TiJQyQJRc_awKdoLTquxOSb0KvRnZMU
"""

import math
import numpy as np
from scipy import integrate

import numpy as np
import matplotlib.pyplot as plt

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.linalg import eig




def rayleigh(map, curves):
  dotFF_1 = lambda y,func,i,j: (map[i][0] *map[j][0] /(map[i][0]+map[j][0]-1) )  * ( (func(y)**(map[i][0] + map[j][0]-1)) * y ** (map[i][1]+map[j][1]) )
  dotFF_2 = lambda y,func,i,j: (map[i][1] *map[j][1] /(map[i][0]+map[j][0]+1) )  * ( (func(y)**(map[i][0] + map[j][0])) * y ** (map[i][1]+map[j][1]-2) )

  FF = lambda y,func,i,j: (1/(map[i][0] +map[j][0] + 1)) * func(y)**(map[i][0]+map[j][0]+1) * (y)**(map[i][1]+map[j][1])

  A = []
  B = []

  for i in range(len(map)):
    AA = []
    for j in range(len(map)):
      res=0
      for curve in curves:
        res1, err = integrate.quad(dotFF_1,curve[1],curve[2], args=(curve[0],i,j,))
        res2, err = integrate.quad(dotFF_2, curve[1],curve[2], args=(curve[0],i,j,))
        res += res1+res2    
      AA.append(res)
    A.append(AA)


  for i in range(len(map)):
    BB = []
    for j in range(len(map)):
      res=0
      for curve in curves:
        r, err = integrate.quad(FF, curve[1],curve[2], args=(curve[0],i,j,))
        res+=r
      BB.append(res)
    B.append(BB)

  A = np.array(A)
  B = np.array(B)


  eigenvalues, eigenvectors = eig(A, B)
  return (eigenvalues, eigenvectors)

map = []
map.append((1,1))
map.append((1,2))
map.append((2,1))
map.append((1,3))
map.append((2,2))
map.append((3,1))

curves = []

curves.append([lambda y: -y+1, 0, 1])         # New curve (y=x)


eigenvalues, eigenvectors = rayleigh(map, curves)

def phi(X, Y, eigenvector,curves):
    res = np.zeros_like(X)  # Initialize result array
    mask = np.zeros(X.shape, dtype=bool)  # Create an empty mask
    
    for curve in curves:
        mask |= (X >= 0) & (X <= curve[0](Y)) & (Y >= 0) & (Y <= 1)
    

    if np.any(mask):  # Check if there are any valid points
        for i in range(len(eigenvector)):
            res[mask] += eigenvector[i] * (X[mask] ** map[i][0]) * (Y[mask] ** map[i][1])
    
    return res

x = np.linspace(-0.1, 1.1, 250)
y = np.linspace(-0.1, 1.1, 250)
X, Y = np.meshgrid(x, y)

fig, ax = plt.subplots(figsize=(10, 8))

def update(i):
    ax.clear()  # Clear previous plot
    Z = phi(X, Y, eigenvectors[i].real,curves)  # Combine base function with eigenvector
    contour = ax.contourf(X, Y, Z, levels=100, cmap='inferno')  # Create a filled contour plot
    ax.set_title(f"Eigenvector {i + 1}: Eigenvalue {eigenvalues[i].real:.2f}")
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_xlim(-0.1, 1.1)
    ax.set_ylim(-0.1, 1.1)
    return contour

ani = FuncAnimation(fig, update, frames=len(eigenvectors), interval=1000, repeat=True)

ani.save('waveguide_triangle_2.gif', writer='pillow', fps=1)

plt.show()
